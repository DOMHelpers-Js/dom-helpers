<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Demo: Selector.waitForAll()</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: sans-serif; background: #f0f2f5; padding: 24px; }
    h1 { font-size: 22px; margin-bottom: 4px; color: #1a1a2e; }
    .subtitle { font-size: 14px; color: #555; margin-bottom: 24px; }
    h2 { font-size: 14px; font-weight: 700; color: #888; text-transform: uppercase; letter-spacing: .6px; margin-bottom: 10px; margin-top: 24px; }

    /* ── Comparison card ── */
    .compare-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-bottom: 20px; }
    .compare-card { background: #fff; border-radius: 10px; padding: 14px 16px; border: 2px solid #e2e8f0; }
    .compare-card h3 { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: .5px; color: #888; margin-bottom: 8px; }
    .compare-card code { display: block; font-size: 12px; background: #f1f5f9; padding: 8px 10px; border-radius: 6px; line-height: 1.7; white-space: pre; margin-bottom: 6px; }
    .compare-card .desc { font-size: 12px; color: #666; }

    /* ── Status banner ── */
    .status-banner {
      border-radius: 10px; padding: 14px 18px; font-size: 14px; font-weight: 700;
      border: 2px solid; text-align: center; margin-bottom: 16px; transition: all .3s;
    }
    .status-banner.idle    { background: #f8fafc; border-color: #e2e8f0; color: #94a3b8; font-family: monospace; }
    .status-banner.waiting { background: #fef9c3; border-color: #fde047; color: #854d0e; font-family: monospace; }
    .status-banner.success { background: #f0fdf4; border-color: #86efac; color: #15803d; font-family: monospace; }
    .status-banner.timeout { background: #fff5f5; border-color: #fca5a5; color: #b91c1c; font-family: monospace; }

    /* ── Inject zone ── */
    .inject-zone {
      background: #fff; border-radius: 12px; padding: 16px 18px;
      border: 2px dashed #7dd3fc; margin-bottom: 16px; min-height: 80px;
    }
    .inject-zone .zone-label { font-size: 12px; color: #aaa; font-style: italic; }
    .injected-el {
      display: inline-block; margin: 4px; padding: 7px 14px; border-radius: 8px;
      background: #e0f2fe; border: 2px solid #38bdf8; font-weight: 700;
      color: #0c4a6e; font-size: 13px; animation: pop .3s ease;
    }
    @keyframes pop { from { transform: scale(.7); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    /* ── Progress bar ── */
    .progress-wrap { background: #e2e8f0; border-radius: 99px; height: 10px; margin-bottom: 10px; overflow: hidden; }
    .progress-bar  { height: 100%; border-radius: 99px; background: #0891b2; width: 0%; transition: width .3s; }

    /* ── Controls ── */
    .controls {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      background: #fff; padding: 12px 16px; border-radius: 10px;
      border: 1px solid #e2e8f0; margin-bottom: 14px;
    }
    .controls label { font-size: 13px; font-weight: 600; color: #444; }
    .controls input[type=number] {
      padding: 6px 10px; border: 1.5px solid #dde1e7; border-radius: 6px;
      font-size: 13px; font-family: monospace; outline: none; width: 75px;
    }
    .btn { padding: 7px 16px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; color: #fff; }
    .btn-run     { background: #0891b2; } .btn-run:hover     { background: #0e7490; }
    .btn-partial { background: #d97706; } .btn-partial:hover { background: #b45309; }
    .btn-timeout { background: #dc2626; } .btn-timeout:hover { background: #b91c1c; }
    .btn-reset   { background: #6b7280; } .btn-reset:hover   { background: #4b5563; }

    .results { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; }
    .result-row { display: flex; align-items: center; gap: 10px; background: #fff; border-radius: 8px; padding: 10px 14px; border-left: 4px solid #ccc; font-size: 14px; color: #333; }
    .result-row.pass { border-left-color: #16a34a; }
    .result-row.fail { border-left-color: #dc2626; background: #fff5f5; }
    .badge { font-size: 11px; font-weight: 700; padding: 2px 8px; border-radius: 99px; flex-shrink: 0; }
    .pass .badge { background: #dcfce7; color: #15803d; }
    .fail .badge { background: #fee2e2; color: #b91c1c; }
  </style>
</head>
<body>
  <h1>Demo — <code>Selector.waitForAll(selector, minCount?, timeout?)</code></h1>
  <p class="subtitle">Returns a Promise that resolves with an enhanced collection once <strong>at least <code>minCount</code></strong> elements matching <code>selector</code> exist in the DOM. Polls every 100 ms. Rejects if the count is never reached within <code>timeout</code> ms (default 5000). Pairs with <code>waitFor()</code> which waits for a single element.</p>

  <!-- ── Comparison ── -->
  <h2>waitFor() vs waitForAll()</h2>
  <div class="compare-grid">
    <div class="compare-card">
      <h3>waitFor() — single</h3>
      <code>await Selector.waitFor(
  '.item',
  3000      // timeout
)</code>
      <div class="desc">Resolves when <strong>1</strong> matching element appears. Returns that element.</div>
    </div>
    <div class="compare-card">
      <h3>waitForAll() — multiple</h3>
      <code>await Selector.waitForAll(
  '.item',
  3,        // minCount
  3000      // timeout
)</code>
      <div class="desc">Resolves when <strong>≥ minCount</strong> matching elements appear. Returns the enhanced collection.</div>
    </div>
  </div>

  <!-- ── Status ── -->
  <div class="status-banner idle" id="status-banner">Idle — press a button to start</div>

  <!-- ── Progress ── -->
  <div class="progress-wrap"><div class="progress-bar" id="progress-bar"></div></div>

  <!-- ── Inject zone ── -->
  <h2>Inject zone (elements appear here)</h2>
  <div class="inject-zone" id="inject-zone">
    <span class="zone-label" id="zone-label">Elements will be injected here one by one…</span>
  </div>

  <!-- ── Controls ── -->
  <h2>Interactive demo</h2>
  <div class="controls">
    <label>Min count:</label>
    <input type="number" id="min-count" value="3" min="1" max="8" />
    <label>Total inject:</label>
    <input type="number" id="total-inject" value="4" min="1" max="8" />
    <label>Interval (ms):</label>
    <input type="number" id="inject-interval" value="600" min="200" max="2000" step="100" />
    <label>Timeout (ms):</label>
    <input type="number" id="wait-timeout" value="5000" min="500" max="15000" step="500" />
  </div>
  <div class="controls">
    <button class="btn btn-run"     onclick="demoSuccess()">Inject enough → resolves</button>
    <button class="btn btn-partial" onclick="demoPartial()">Inject fewer than minCount → rejects</button>
    <button class="btn btn-timeout" onclick="demoTimeout()">Never inject → rejects (timeout)</button>
    <button class="btn btn-reset"   onclick="demoReset()">Reset</button>
  </div>

  <h2>Automated test results</h2>
  <div class="results" id="results"></div>

  <script src="https://cdn.jsdelivr.net/npm/dom-helpers-js@2.4.3/dist/dom-helpers.min.js"></script>
  <script>
    const resultsEl = document.getElementById('results');
    function addResult(pass, label, detail) {
      const row = document.createElement('div');
      row.className = 'result-row ' + (pass ? 'pass' : 'fail');
      row.innerHTML = '<span class="badge">' + (pass ? 'PASS' : 'FAIL') + '</span><strong>' + label + '</strong>' + (detail ? ' — <span style="color:#666">' + detail + '</span>' : '');
      resultsEl.appendChild(row);
    }

    function setStatus(text, cls) {
      const b = document.getElementById('status-banner');
      b.className = 'status-banner ' + cls;
      b.textContent = text;
    }
    function setProgress(pct) {
      document.getElementById('progress-bar').style.width = Math.min(pct, 100) + '%';
    }

    let injectTimers = [];
    function demoReset() {
      injectTimers.forEach(t => clearTimeout(t));
      injectTimers = [];
      const zone = document.getElementById('inject-zone');
      zone.innerHTML = '<span class="zone-label" id="zone-label">Elements will be injected here one by one…</span>';
      setStatus('Idle — press a button to start', 'idle');
      setProgress(0);
    }

    function scheduleInjects(count, interval, cls) {
      for (let i = 0; i < count; i++) {
        injectTimers.push(setTimeout(() => {
          const zone = document.getElementById('inject-zone');
          const label = document.getElementById('zone-label');
          if (label) label.remove();
          const el = document.createElement('div');
          el.className = 'injected-el ' + cls;
          el.id = cls + '-' + i;
          el.textContent = '#' + (i + 1);
          zone.appendChild(el);
          const minCount = +document.getElementById('min-count').value;
          setProgress(((i + 1) / minCount) * 100);
        }, (i + 1) * interval));
      }
    }

    function demoSuccess() {
      demoReset();
      const minCount = +document.getElementById('min-count').value;
      const total    = +document.getElementById('total-inject').value;
      const interval = +document.getElementById('inject-interval').value;
      const timeout  = +document.getElementById('wait-timeout').value;
      setStatus('⏳ Waiting for ' + minCount + ' .demo-items…', 'waiting');
      scheduleInjects(total, interval, 'demo-item');
      const start = Date.now();
      Selector.waitForAll('.demo-item', minCount, timeout)
        .then(col => {
          const elapsed = Date.now() - start;
          setStatus('✓ Resolved in ' + elapsed + 'ms — found ' + col.length + ' elements', 'success');
          setProgress(100);
        })
        .catch(err => {
          setStatus('✗ ' + err.message, 'timeout');
        });
    }

    function demoPartial() {
      demoReset();
      const minCount = +document.getElementById('min-count').value;
      const interval = +document.getElementById('inject-interval').value;
      const timeout  = +document.getElementById('wait-timeout').value;
      const injectOnly = Math.max(1, minCount - 1); // inject one fewer than needed
      setStatus('⏳ Waiting for ' + minCount + ' .partial-items, only injecting ' + injectOnly + '…', 'waiting');
      scheduleInjects(injectOnly, interval, 'partial-item');
      const start = Date.now();
      Selector.waitForAll('.partial-item', minCount, timeout)
        .then(col => {
          setStatus('Unexpectedly resolved with ' + col.length + ' elements!', 'success');
        })
        .catch(err => {
          const elapsed = Date.now() - start;
          setStatus('✗ Timed out after ' + elapsed + 'ms (only ' + injectOnly + ' of ' + minCount + ' appeared)', 'timeout');
        });
    }

    function demoTimeout() {
      demoReset();
      const timeout = +document.getElementById('wait-timeout').value;
      setStatus('⏳ Waiting for .never-injected-xyz (will time out in ' + timeout + 'ms)…', 'waiting');
      const start = Date.now();
      Selector.waitForAll('.never-injected-xyz', 1, timeout)
        .then(() => setStatus('Unexpectedly resolved!', 'success'))
        .catch(err => {
          const elapsed = Date.now() - start;
          setStatus('✗ Timed out after ' + elapsed + 'ms — ' + err.message, 'timeout');
        });
    }

    // ── Automated tests ────────────────────────────────────────────────────────

    // 1. Returns a Promise
    const p1 = Selector.waitForAll('.nonexistent-abc', 1, 200);
    addResult(p1 instanceof Promise, 'waitForAll() returns a Promise', 'instanceof Promise: true');
    p1.catch(() => {});

    // 2. Resolves when enough elements already exist
    (async () => {
      const els = [];
      for (let i = 0; i < 4; i++) {
        const el = document.createElement('div');
        el.className = 'pre-test-items';
        el.id = 'pti-' + i;
        document.body.appendChild(el);
        els.push(el);
      }

      let col = null;
      let threw = false;
      try { col = await Selector.waitForAll('.pre-test-items', 3, 1000); }
      catch(e) { threw = true; }

      addResult(!threw && col !== null, 'resolves when minCount elements already exist', col ? 'length: ' + col.length : 'timed out');
      addResult(!threw && col && col.length >= 3, 'resolved collection has at least minCount elements', col ? 'length: ' + col.length : 'n/a');

      // collection is enhanced (has .forEach)
      let hasForEach = typeof (col && col.forEach) === 'function';
      addResult(hasForEach, 'resolved value is an enhanced collection (supports .forEach)', '');

      els.forEach(el => el.remove());
    })();

    // 3. Resolves after elements are dynamically injected
    (async () => {
      const injected = [];
      for (let i = 0; i < 3; i++) {
        injectTimers.push(setTimeout(() => {
          const el = document.createElement('div');
          el.className = 'async-test-el';
          el.id = 'ate-' + i;
          document.body.appendChild(el);
          injected.push(el);
        }, (i + 1) * 250));
      }

      let col = null;
      let threw = false;
      try { col = await Selector.waitForAll('.async-test-el', 3, 3000); }
      catch(e) { threw = true; }

      addResult(!threw && col !== null, 'resolves after elements are dynamically injected over time', col ? 'length: ' + col.length : 'timed out');
      injected.forEach(el => { if (el.parentNode) el.remove(); });
    })();

    // 4. Rejects when minCount is never reached within timeout
    (async () => {
      // Only inject 1 element, wait for 3
      const el = document.createElement('div');
      el.className = 'insufficient-els';
      document.body.appendChild(el);

      let threw = false;
      let errMsg = '';
      try { await Selector.waitForAll('.insufficient-els', 3, 400); }
      catch(e) { threw = true; errMsg = e.message; }

      addResult(threw, 'rejects when minCount is never reached within timeout', 'threw: ' + threw);
      addResult(errMsg.length > 0, 'rejection includes an error message', 'msg: ' + errMsg.substring(0, 60));
      el.remove();
    })();

    // 5. minCount defaults to 1 when omitted
    (async () => {
      const el = document.createElement('div');
      el.className = 'default-min-test';
      document.body.appendChild(el);

      let col = null;
      try { col = await Selector.waitForAll('.default-min-test', undefined, 1000); }
      catch(e) {}

      addResult(col !== null && col !== undefined, 'minCount defaults to 1 when omitted — resolves for a single element', col ? 'length: ' + col.length : 'timed out');
      el.remove();
    })();
  </script>
</body>
</html>
