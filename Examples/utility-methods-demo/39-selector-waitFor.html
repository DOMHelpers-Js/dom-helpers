<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Demo: Selector.waitFor()</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: sans-serif; background: #f0f2f5; padding: 24px; }
    h1 { font-size: 22px; margin-bottom: 4px; color: #1a1a2e; }
    .subtitle { font-size: 14px; color: #555; margin-bottom: 24px; }
    h2 { font-size: 14px; font-weight: 700; color: #888; text-transform: uppercase; letter-spacing: .6px; margin-bottom: 10px; margin-top: 24px; }

    /* ── Timeline ── */
    .timeline {
      background: #fff; border-radius: 12px; padding: 18px 20px;
      border: 2px solid #dde1e7; margin-bottom: 16px;
    }
    .tl-row { display: flex; align-items: center; gap: 12px; padding: 8px 0; border-bottom: 1px solid #f3f4f6; font-size: 13px; }
    .tl-row:last-child { border: none; }
    .tl-time { font-family: monospace; font-size: 12px; color: #aaa; min-width: 55px; }
    .tl-dot  { width: 10px; height: 10px; border-radius: 50%; background: #e2e8f0; flex-shrink: 0; }
    .tl-dot.active  { background: #4f46e5; box-shadow: 0 0 6px rgba(79,70,229,.5); }
    .tl-dot.success { background: #16a34a; }
    .tl-dot.timeout { background: #dc2626; }
    .tl-label { color: #555; }
    .tl-label.active  { color: #4f46e5; font-weight: 600; }
    .tl-label.success { color: #15803d; font-weight: 700; }
    .tl-label.timeout { color: #b91c1c; font-weight: 700; }

    /* ── Inject zone ── */
    .inject-zone {
      background: #fff; border-radius: 12px; padding: 16px 18px;
      border: 2px dashed #c4b5fd; margin-bottom: 16px; min-height: 70px;
      display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
    }
    .inject-zone .zone-label { font-size: 12px; color: #aaa; font-style: italic; }
    .injected-el {
      padding: 8px 16px; border-radius: 8px; background: #ede9fe;
      border: 2px solid #a78bfa; font-weight: 700; color: #5b21b6;
      font-size: 13px; animation: pop .3s ease;
    }
    @keyframes pop { from { transform: scale(.7); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    /* ── Status banner ── */
    .status-banner {
      border-radius: 10px; padding: 14px 18px; font-family: monospace; font-size: 14px;
      font-weight: 700; border: 2px solid; text-align: center; margin-bottom: 16px;
      transition: all .3s;
    }
    .status-banner.idle    { background: #f8fafc; border-color: #e2e8f0; color: #94a3b8; }
    .status-banner.waiting { background: #fef9c3; border-color: #fde047; color: #854d0e; }
    .status-banner.success { background: #f0fdf4; border-color: #86efac; color: #15803d; }
    .status-banner.timeout { background: #fff5f5; border-color: #fca5a5; color: #b91c1c; }

    /* ── Controls ── */
    .controls {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      background: #fff; padding: 12px 16px; border-radius: 10px;
      border: 1px solid #e2e8f0; margin-bottom: 14px;
    }
    .controls label { font-size: 13px; font-weight: 600; color: #444; }
    .controls input[type=number] {
      padding: 6px 10px; border: 1.5px solid #dde1e7; border-radius: 6px;
      font-size: 13px; font-family: monospace; outline: none; width: 80px;
    }
    .btn { padding: 7px 16px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; color: #fff; }
    .btn-run     { background: #4f46e5; } .btn-run:hover     { background: #4338ca; }
    .btn-timeout { background: #dc2626; } .btn-timeout:hover { background: #b91c1c; }
    .btn-reset   { background: #6b7280; } .btn-reset:hover   { background: #4b5563; }

    .results { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; }
    .result-row { display: flex; align-items: center; gap: 10px; background: #fff; border-radius: 8px; padding: 10px 14px; border-left: 4px solid #ccc; font-size: 14px; color: #333; }
    .result-row.pass { border-left-color: #16a34a; }
    .result-row.fail { border-left-color: #dc2626; background: #fff5f5; }
    .badge { font-size: 11px; font-weight: 700; padding: 2px 8px; border-radius: 99px; flex-shrink: 0; }
    .pass .badge { background: #dcfce7; color: #15803d; }
    .fail .badge { background: #fee2e2; color: #b91c1c; }
  </style>
</head>
<body>
  <h1>Demo — <code>Selector.waitFor(selector, timeout?)</code></h1>
  <p class="subtitle">Returns a Promise that resolves with the first matching element as soon as it appears in the DOM. Polls every 100 ms up to <code>timeout</code> (default 5000 ms). Rejects with an <code>Error</code> if the element never appears within the timeout.</p>

  <!-- ── How it works ── -->
  <h2>How it works</h2>
  <div class="timeline" id="timeline">
    <div class="tl-row"><span class="tl-time">t = 0</span><span class="tl-dot"></span><span class="tl-label">waitFor() called — starts polling every 100 ms</span></div>
    <div class="tl-row"><span class="tl-time">t = Nms</span><span class="tl-dot"></span><span class="tl-label">Element injected into DOM</span></div>
    <div class="tl-row"><span class="tl-time">t ≤ N+100</span><span class="tl-dot"></span><span class="tl-label">Next poll detects element → Promise resolves</span></div>
    <div class="tl-row"><span class="tl-time">t > timeout</span><span class="tl-dot"></span><span class="tl-label">If element never appears → Promise rejects with Error</span></div>
  </div>

  <!-- ── Status ── -->
  <div class="status-banner idle" id="status-banner">Idle — press a button to start</div>

  <!-- ── Inject zone ── -->
  <h2>Inject zone (elements appear here)</h2>
  <div class="inject-zone" id="inject-zone">
    <span class="zone-label">Elements will be injected here after a delay…</span>
  </div>

  <!-- ── Controls ── -->
  <h2>Interactive demo</h2>
  <div class="controls">
    <label>Inject after:</label>
    <input type="number" id="inject-delay" value="1500" min="100" max="8000" step="100" />
    <span style="font-size:13px;color:#888">ms</span>
    <label>Timeout:</label>
    <input type="number" id="wait-timeout" value="3000" min="500" max="10000" step="500" />
    <span style="font-size:13px;color:#888">ms</span>
    <button class="btn btn-run"     onclick="demoSuccess()">Inject before timeout → resolves</button>
    <button class="btn btn-timeout" onclick="demoTimeout()">Never inject → rejects (timeout)</button>
    <button class="btn btn-reset"   onclick="demoReset()">Reset</button>
  </div>

  <h2>Automated test results</h2>
  <div class="results" id="results"></div>

  <script src="https://cdn.jsdelivr.net/npm/dom-helpers-js@2.4.3/dist/dom-helpers.min.js"></script>
  <script>
    const resultsEl = document.getElementById('results');
    function addResult(pass, label, detail) {
      const row = document.createElement('div');
      row.className = 'result-row ' + (pass ? 'pass' : 'fail');
      row.innerHTML = '<span class="badge">' + (pass ? 'PASS' : 'FAIL') + '</span><strong>' + label + '</strong>' + (detail ? ' — <span style="color:#666">' + detail + '</span>' : '');
      resultsEl.appendChild(row);
    }

    function setStatus(text, cls) {
      const b = document.getElementById('status-banner');
      b.className = 'status-banner ' + cls;
      b.textContent = text;
    }

    let activeTimer = null;
    function demoReset() {
      if (activeTimer) { clearTimeout(activeTimer); activeTimer = null; }
      const zone = document.getElementById('inject-zone');
      zone.innerHTML = '<span class="zone-label">Elements will be injected here after a delay…</span>';
      setStatus('Idle — press a button to start', 'idle');
    }

    function demoSuccess() {
      demoReset();
      const delay   = +document.getElementById('inject-delay').value;
      const timeout = +document.getElementById('wait-timeout').value;
      setStatus('⏳ Waiting for #dynamic-el to appear…', 'waiting');

      // Inject element after delay
      activeTimer = setTimeout(() => {
        const el = document.createElement('div');
        el.className = 'injected-el';
        el.id = 'dynamic-el';
        el.textContent = '#dynamic-el injected!';
        document.getElementById('inject-zone').appendChild(el);
      }, delay);

      const start = Date.now();
      Selector.waitFor('#dynamic-el', timeout)
        .then(el => {
          const elapsed = Date.now() - start;
          setStatus('✓ Resolved in ' + elapsed + 'ms — found: #' + el.id, 'success');
        })
        .catch(err => {
          setStatus('✗ ' + err.message, 'timeout');
        });
    }

    function demoTimeout() {
      demoReset();
      const timeout = +document.getElementById('wait-timeout').value;
      setStatus('⏳ Waiting for #will-never-exist (will time out in ' + timeout + 'ms)…', 'waiting');

      const start = Date.now();
      Selector.waitFor('#will-never-exist', timeout)
        .then(() => {
          setStatus('Unexpectedly resolved!', 'success');
        })
        .catch(err => {
          const elapsed = Date.now() - start;
          setStatus('✗ Timed out after ' + elapsed + 'ms — ' + err.message, 'timeout');
        });
    }

    // ── Automated tests ────────────────────────────────────────────────────────

    // 1. Returns a Promise
    const p1 = Selector.waitFor('.scard-existing-xyz', 200);
    addResult(p1 instanceof Promise, 'waitFor() returns a Promise', 'instanceof Promise: ' + (p1 instanceof Promise));
    p1.catch(() => {}); // suppress unhandled rejection

    // 2. Resolves when element already exists
    (async () => {
      // Create a pre-existing element
      const existing = document.createElement('div');
      existing.id = 'pre-existing-test';
      existing.className = 'pre-existing';
      document.body.appendChild(existing);

      let resolvedEl = null;
      let threw = false;
      try {
        resolvedEl = await Selector.waitFor('#pre-existing-test', 1000);
      } catch(e) { threw = true; }

      addResult(!threw && resolvedEl !== null, 'waitFor() resolves immediately when element already exists', resolvedEl ? '#' + resolvedEl.id : 'null');
      addResult(!threw && resolvedEl && resolvedEl.id === 'pre-existing-test', 'resolved value is the matching DOM element', resolvedEl ? '#' + resolvedEl.id : 'null');

      existing.remove();
    })();

    // 3. Resolves after element is dynamically injected
    (async () => {
      // Inject after 300ms
      const timer = setTimeout(() => {
        const el = document.createElement('div');
        el.id = 'late-arrival';
        document.body.appendChild(el);
      }, 300);

      let resolvedEl = null;
      let threw = false;
      try {
        resolvedEl = await Selector.waitFor('#late-arrival', 2000);
      } catch(e) { threw = true; clearTimeout(timer); }

      addResult(!threw && resolvedEl !== null, 'waitFor() resolves after element is dynamically injected (after 300ms)', resolvedEl ? '#' + resolvedEl.id : 'timed out');
      addResult(!threw && resolvedEl && resolvedEl.nodeType === Node.ELEMENT_NODE, 'resolved value is a DOM element (nodeType === 1)', resolvedEl ? 'nodeType: ' + resolvedEl.nodeType : 'n/a');

      if (resolvedEl) resolvedEl.remove();
    })();

    // 4. Rejects when element never appears within timeout
    (async () => {
      let threw = false;
      let errMsg = '';
      try {
        await Selector.waitFor('#never-appears-xyz', 300);
      } catch(e) { threw = true; errMsg = e.message; }

      addResult(threw, 'waitFor() rejects when element never appears within timeout', 'threw: ' + threw);
      addResult(errMsg.length > 0, 'rejection includes an error message', 'msg: ' + errMsg.substring(0, 60));
    })();

    // 5. Works with class selectors
    (async () => {
      const el = document.createElement('div');
      el.className = 'wait-class-test';
      setTimeout(() => document.body.appendChild(el), 200);

      let resolvedEl = null;
      try { resolvedEl = await Selector.waitFor('.wait-class-test', 1500); } catch(e) {}

      addResult(resolvedEl !== null && resolvedEl !== undefined, 'waitFor() works with class selectors', resolvedEl ? 'found: ' + resolvedEl.className : 'not found');
      if (resolvedEl) resolvedEl.remove();
    })();
  </script>
</body>
</html>
